uint32_t s[4][256];
uint32_t dynamic_keys[18];
uint32_t keys[18];
void blowfish();
void creating_dynamic_keys();
uint64_t fastly(uint64_t number);
void swap(uint32_t* L, uint32_t* R);
uint32_t foo(uint32_t number_32);
char *readline(const char* str);

int main()
{
    creating_dynamic_keys();
    blowfish();
    return 0;
}
void
creating_dynamic_keys()
{
    char* key8 = NULL;
    key8 = readline("Enter a key: ");
    int len_key;
    len_key = strlen(key8);
    uint32_t xor_key_32;
    int i = 0;

    for (int kol = 0; kol <= 17; kol++)
    {
        xor_key_32 = 0;
        for (int k = 0; k <= 24; k += 8)
        {
            char a = key8[i];
            xor_key_32 |= (uint32_t)key8[i] << k;
            i += 1;
            if (i == len_key)
            {
                i = 0;
            }
        }
        dynamic_keys[kol] = static_keys[kol] ^ xor_key_32;
        printf("  k%x", dynamic_keys[kol]);
    }
    free(key8);
    for (int i = 0; i <= 3; i++)
    {
        for (int j = 0; j <= 255; j++)
        {
            s[i][j] = static_s[i][j];
        }
    } uint64_t plpr = fastly(0), c;

    for (int i = 0; i < 18; i += 2)
    {
        dynamic_keys[i] = (plpr >> 32);
        dynamic_keys[i + 1] = plpr;
        c = (uint64_t)dynamic_keys[i] << 32 | dynamic_keys[i + 1];
        plpr = fastly(c);
    } for (int i = 0; i <= 3; i++)

    {
        for (int j = 0; j < 255; j += 2)
        {
            s[i][j] = plpr << 32;
            s[i][j + 1] = plpr;
            c = (uint64_t)s[i][j] << 32 + s[i][j + 1];
            plpr = fastly(c);
        }
    }
}

uint64_t fastly(uint64_t number)
{
    uint32_t left_number, right_number;
    right_number = number;
    left_number = (number >> 32);
    for (int i = 0; i < 16; i++)
    {
        left_number ^= dynamic_keys[i];
        right_number = foo(left_number) ^ right_number;
        swap(&left_number, &right_number);
    }
    swap(&left_number, &right_number);
    right_number ^= dynamic_keys[16];
    left_number ^= dynamic_keys[17];
    return ((uint64_t)left_number << 32) + right_number;
}
uint32_t foo(uint32_t number_32)
{
    uint8_t plase_1, plase_2, plase_3, plase_4;
    plase_1 = (number_32 >> 24);
    plase_2 = (number_32 >> 16);
    plase_3 = (number_32 >> 8);
    plase_4 = number_32;
    number_32 = s[0][plase_1];
    number_32 |= s[1][plase_2];
    number_32 ^= s[2][plase_3];
    number_32 |= s[3][plase_4];
    return number_32;
}

void swap(uint32_t* L, uint32_t* R)
{
    uint32_t tmp = *L;
    *L = *R;
    *R = tmp;
    return;
}
void blowfish()
{
    char* text = NULL;
    text = readline("Enter a text: ");
    char* encryption_text = NULL;
    int len = strlen(text);
    encryption_text = (char*)malloc((len + 16) * sizeof(char));
    char* decryption_text = NULL;
    decryption_text = (char*)malloc((len + 16) * sizeof(char));
    uint64_t block_64;
    int mod = 0, number = 0;
    uint8_t symbol;
    while (number < len)
    {
        block_64 = 0;
        for (int i = 56; i >= 0; i -= 8)
        {
            uint8_t a = text[number];
            block_64 |= (uint64_t)a << i;
            number += 1;
        }
        block_64 = fastly(block_64);
        int e = 56;
        char* tmp_str;
        tmp_str = (char*)malloc(9 * sizeof(char));
        for (int k = 0; k < 8; k++)
        {
            symbol = block_64 >> e;
            tmp_str[k] = symbol;
            e -= 8;
        }
        strcat(encryption_text, tmp_str);
        free(tmp_str);
    }
    printf("Enctyption text: %s\n", encryption_text);
    uint32_t tmp_key[18];
    for (int i = 0; i <= 17; i++)
    {
        tmp_key[17 - i] = dynamic_keys[i];
    }
    for (int i = 0; i <= 17; i++)
    {
        dynamic_keys[i] = tmp_key[i];
    }
    number = 0;
    while (number < len)
    {
        block_64 = 0;
        for (int i = 56; i >= 0; i -= 8)
        {
            uint8_t a = encryption_text[number];
            block_64 |= (uint64_t)a << i;
            number += 1;
        }
        block_64 = fastly(block_64);
        int e = 56;
        char* tmp_str;
        tmp_str = (char*)malloc(9 * sizeof(char));
        for (int k = 0; k < 8; k++)
        {
            symbol = block_64 >> e;
            tmp_str[k] = symbol;
            e -= 8;
        }
        strcat(decryption_text, tmp_str);
        free(tmp_str);
    }
    printf("Decryption text: %s\n", decryption_text);
    free(text);
    free(encryption_text);
    free(decryption_text);
    return;
}

char *readline(const char* str)
{
    printf("%s", str);
    char buf[81] = {0};
    char *res = NULL;
    int len = 0;
    int n = 0;
    do {
 n = scanf("%80[^\n]", buf);
        if (n < 0) {
            if (!res) {
                return NULL;
            }
        }
        else if (n > 0) {
            int chunk_len = strlen(buf);
            int str_len = len + chunk_len;
            res = realloc(res, str_len + 1);
            memcpy(res + len, buf, chunk_len);
            len = str_len;
        }
        else {
            scanf("%*c");
        }
 } while (n > 0);

    if (len > 0) {
        res[len] = '\0';
    }
    else {
        return "";
    }
    return res;
}